Билет №18:

1.  Многопоточность. Интерфейсы Callable, Runnable, Future. Класс Thread.

2. 	Spring boot – что это такое и для чего используется. Основные составляющие Spring. Как устроен, что позволяет сделать.
Какие есть аннотации. Основной скелет проекта. Аннотации @Repository, @Component, @Bean, @SpringBootApplication,
@Service, @Entity, @Controller, @RestController, @Configuration, @Valid и другие. Конфигурационные файлы *.yaml,*.conf,
*.properties. Swagger. Основные библиотеки и плагины в gradle для работы с БД, валидацией, MVC, UI.

3.  Реализуйте аутентификацию с помощью токенов, хранящихся в Redis. Токен должен быть строкой UUID. TTL токена должен задаваться в конфигурации приложения Spring в файле application.yml. Для реализации аутентификации нужно использовать Spring Security.
Для проверки реализуйте класс TokenVerification, который будет использован в FilterChain, с одним методом boolean verify(UUID token), внутри которого происходит проверка наличия в Redis и проверка срока действия. Для выдачи токена реализуйте эндпоинт /api/v1/mai/register,
который будет отдавать строку UUID - токен пользователя.

Вопрос 1.
В Java многопоточность реализуется через классы и интерфейсы, позволяющие выполнять несколько задач параллельно.
Интерфейс Runnable предоставляет метод run() для определения логики потока, в то время как Callable позволяет возвращать результат и обрабатывать исключения.
Интерфейс Futureпредоставляет методы для получения результата работы Callable и управления его выполнением.
Класс Thread представляет собой поток исполнения и может быть использован для создания и управления потоками, но предпочтительнее использовать Runnable или Callable для логики потока.

Интерфейс Runnable:
Используется для определения задач, которые будут выполняться в отдельном потоке.
Содержит единственный метод run(), в котором определяется логика работы потока.
Не возвращает значения и не обрабатывает исключения.
Подходит для простых задач, не требующих возврата результата или обработки исключений.
Создание потока через Runnable предполагает создание экземпляра класса Thread и передачу в него объекта Runnable.

Интерфейс Callable:
Также используется для определения задач, выполняемых в отдельном потоке.
Содержит метод call(), который может возвращать результат и обрабатывать исключения.
Подходит для более сложных задач, требующих возврата результата или обработки исключений.
Для получения результата работы Callableиспользуется интерфейс Future.

Интерфейс Future:
Представляет собой результат асинхронного вычисления, возвращаемый Callable.
Предоставляет методы для проверки завершения выполнения потока, получения результата и обработки исключений.
Обеспечивает связь между потоком, выполняющим Callable, и потоком, который ожидает результат.

Класс Thread:
Представляет собой поток исполнения в Java.
Может быть создан путем наследования от класса Thread и переопределения метода run().
Однако, рекомендуется использовать Runnableили Callable для определения логики потока, а Thread – для управления потоком.
Класс Thread предоставляет методы для управления потоком, такие как start(), stop(), sleep() и т.д.

Взаимодействие:
Для выполнения задачи в отдельном потоке создается экземпляр Runnable или Callable.
Создается объект Thread, который получает в конструкторе экземпляр Runnable или Callable.
Метод start() класса Thread запускает поток, который начинает выполнять метод run() у Runnable или call() у Callable.
Если используется Callable, то для получения результата используется Future, полученный через ExecutorService.

Пример использования
import java.util.concurrent.*;

class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Работает поток, реализованный через Runnable");
    }
}

class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        System.out.println("Работает поток, реализованный через Callable");
        return 123;
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        // Runnable
        Thread thread1 = new Thread(new MyRunnable());
        thread1.start();
        thread1.join(); // Ждем завершения потока

        // Callable
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<Integer> future = executor.submit(new MyCallable());
        Integer result = future.get(); // Получаем результат
        System.out.println("Результат работы Callable: " + result);
        executor.shutdown();
    }
}

Вопрос 2.
Что такое Spring Boot
Spring Boot - это часть фреймворка Spring, которая представляет собой набор инструментов и библиотек для создания
приложений корпоративного уровня.
Spring Boot упрощает создание автономных приложений на базе Spring производственного уровня, которые вы можете
"просто запустить".

Характеристики
- Создание автономных приложений Spring
- Встраивать Tomcat, Jetty или Undertow напрямую (нет необходимости развертывать файлы WAR)
- Предоставьте самоуверенные "начальные" зависимости для упрощения настройки сборки
- По возможности автоматически настраивайте библиотеки Spring и сторонних производителей
- Предоставляет готовые к работе функции, такие как метрики, проверки работоспособности и внешняя конфигурация
- Абсолютно не генерирует код и не требует настройки XML

Как устроен Spring
Java Spring Framework - это большой набор разных мини-фреймворков. Каждый из них нужен для работы над
определёнными приложениями или их частями.

Основные компоненты
1) IoC
Этот модуль лежит в основе Spring и контролирует взаимодействие разных компонентов между собой.
С помощью специальных аннотаций можно описать зависимости между компонентами, соединяя их в единую архитектуру.
В итоге компоненты работают сами по себе, а связями между ними управляет специальный контейнер.
Это позволяет даже в случае изменения компонентов сохранять работоспособность всей системы.

2) Модуль доступа к данным
Объединяет сразу несколько библиотек и отвечает за взаимодействие программ с базами данных.
Этот модуль превращает объекты Java в записи базы данных, позволяет вносить изменения, организовывать быстрый и
безопасный доступ к данным.

3) Spring Cloud
Этот модуль позволяет интегрировать между собой разные элементы систем, соединённые по сети: компьютеры, серверы,
PaaS-платформы и другие. Для некоторых популярных решений есть отдельные подмодули, например Spring Cloud Azure.
Внутри Spring Cloud есть инструменты для маршрутизации запросов, балансировки нагрузки на отдельные сервисы и обмена
сообщениями.

4) AOP-модуль
Позволяет реализовать не совсем стандартную парадигму — аспектно-ориентированное программирование.
С его помощью программу можно сделать более выразительной и чёткой за счёт разделения на отдельно функционирующие
части с разными зонами ответственности. АОП позволяет неявно работать с разными функциями системы так, что они не
могут помешать работе друг друга. Это улучшает архитектуру приложения и позволяет программисту не отвлекаться от бизнес-задач
на рутину.

5) Модуль транзакций
В Java транзакциями называют последовательность запросов к БД.
Модуль транзакций выполняет важные запросы надёжнее и гарантирует сохранность данных.

6) Модуль MVC
Этот модуль реализует популярную схему веб-приложений — разделение её на три части.
Первая часть отвечает за данные, вторая — за отображение интерфейсов, третья — за изменение данных в ответ на
действия пользователя.

7) Модуль авторизации
Этот модуль позволяет настраивать авторизацию и аутентификацию в системе.
Он обеспечивает разделение прав пользователей и защиту паролей.

8) Модуль бизнес-приложений
Это фреймворк Spring Roo, который позволяет быстро создавать структуру крупных приложений и универсальные шаблонные решения.

9) Модуль интеграции
Он называется Spring Integration и предназначен для того, чтобы интегрировать корпоративные приложения в единую систему:
обмениваться сообщениями, активировать функции и строить единую архитектуру.

10) Spring Boot
Это отдельный модуль, который упрощает настройку фреймворка Spring и ускоряет запуск проектов.
Он может автоматически сконфигурировать приложение и создать веб-сервер для его запуска.
Большинство новых приложений Spring создаётся с помощью Spring Boot.

Основной скелет проекта
@SpringBootApplication
public class Application {
	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}

Любой проект, созданной на основе Spring Boot содержит подобного рода строки. Под капотом этих аннотаций выполняется большое количество действий, которые скрыты для удобства разработки.
Во-первых эта аннотация автоматически настраивает сканирование (содержит аннотацию @ComponentScan) классов для поиска bean компонентов - она ищет компоненты в директории, где находится класс, помеченный аннотацией @SpringBootApplication.
Во-вторых помечает класс аннотацией @Configuration, что означает, что класс является источником определений компонентов для контекста приложения.
В-третьих помечает класс аннотацией @EnableAutoConfiguration: Сообщает Spring Boot начать добавлять компоненты на основе настроек classpath, других компонентов и различных настроек свойств. Например, если spring-webmvc находится в пути к классу, эта аннотация помечает приложение как веб-приложение и активирует ключевые действия, такие как настройка DispatcherServlet.
@Repository
Указывает, что аннотированный класс является "Репозиторием", первоначально определенным как "механизм для инкапсуляции хранилища, извлечения и поискового поведения, который эмулирует коллекцию объектов".
@Component
Общая аннотация, которая указывает, что класс является частью компонентов приложения.
Она не предоставляет никакой дополнительной функциональности, и её можно считать «по умолчанию» для любого Spring-управляемого компонента.
@Bean
Это аннотация Spring Framework, которая используется над методом для указания того, что данный метод создаёт, настраивает и инициализирует новый объект, управляемый контейнером Spring IoC.
Такие методы можно использовать как в классах с аннотацией @Configuration, так и в классах с аннотацией @Component (или её наследниках).
@SpringBootApplication
Аннотация @SpringBootApplication — это мощная и фундаментальная аннотация в рамках Spring Boot. Она объединяет несколько других аннотаций и служит точкой входа для приложения Spring Boot.
Аннотация @SpringBootApplication состоит из трёх аннотаций:
@SpringBootConfiguration — указывает, что этот класс предоставляет конфигурацию для приложения.
@EnableAutoConfiguration — включает механизм автоматической настройки Spring Boot, который автоматически настраивает приложение на основе библиотек в пути к классам.
@ComponentScan — указывает Spring просканировать указанный пакет (и подпакеты) на наличие аннотированных компонентов.
@Service
Эта аннотация показывает, что класс представляет собой сервис для реализации бизнес-логики.
Эта аннотация не отличается от аннотации @Component, однако она помогает программисту указать смысловую нагрузку используемого класса.
@Entity
Аннотация @Entity в Hibernate указывает, что класс является сущностью, связанной с таблицей в базе данных
@Controller
Указывает, что аннотированный класс является "Контроллером" (например, веб-контроллером).
Эта аннотация служит специализацией @Component, позволяя автоматически определять классы реализации посредством сканирования путей к классам. Обычно она используется в сочетании с аннотированными методами обработчика, основанными на RequestMapping аннотации.
@RestController
Аннотация @RestController появилась в Spring 4.0 и объединяет в себе аннотации @Controller и @ResponseBody.
Она не только помечает класс как Spring MVC Controller, но и автоматически преобразует возвращаемые контроллером данные в формат JSON или XML.
Основное различие между @Controller и @RestController заключается в следующем:
@Controller используется для обработки веб-страниц;
@RestController — для создания RESTful веб-сервисов, которые возвращают данные в формате JSON или XML.
@Configuration
@Configuration - это аннотация Spring Core, которая при аннотации поверх класса означает, что этот класс содержит определения для различных Java-компонентов, аннотированных с помощью @Bean, которые будут управляться контейнером Spring IoC. Эта аннотация также содержит семантику @Component, которая сообщает spring Framework, что этот класс должен быть обнаружен при сканировании компонентов.
@Valid
Аннотация @Valid используется для запуска процесса валидации при обработке запроса в Spring.
Она не является специфичной для Spring и может использоваться в любом Java-приложении.
Функция @Valid:
Проверка объекта метода или параметра в методе.
Используется, когда объект получен в HTTP-запросе и требуется проверить поля этого объекта.
Другие аннотации
Остальные аннотации можно найти на сайте документации spring framework
Конфигурационные файлы
Конфигурацию приложения Spring можно настраивать двумя способами - *.properties или *.yml файлами. Разницы в использовании никакой нет, они отличаются лишь внешним видом и определенным синтаксисом для файла с расширением.
Если определить 2 файла сразу - *.properties и *.yml, то эти два файла смерджатся.
Насчет файлов *.conf - это я хз, мы их использовали только для конфигурации Kafka, но для конфигурации приложения - нет.
Swagger
Swagger - это инструмент, который помогает разработчикам создавать, документировать и проверять API. API - это набор правил и и протоколов, которые позволяют различным системам обмениваться информацией между собой.
Часть работы с REST API — это создание описаний работы API: информации о ресурсах, параметрах запросов, возвращаемых данных, конечных точках и других важных вещах. Чтобы автоматизировать это описание, сделать его структурированным и прозрачным, разработчики используют Swagger. А системные аналитики, в свою очередь, с его помощью формируют требования к IT-системам.
Пример использования автоматической документации из лабораторных работ
Подключение библиотек в gradle:
//open api, swagger
implementation group: 'org.springdoc', name: 'springdoc-openapi-starter-webmvc-ui', version: '2.0.2'
implementation 'io.swagger:swagger-models:1.6.10'
Код контроллера:
@RestController
public class TestController {
    @GetMapping
    @ResponseStatus(HttpStatus.OK)
    @Operation(summary = "Сделать GET запрос")
    public String getMapping() {
        return "get";
    }

    @PostMapping
    @ResponseStatus(HttpStatus.OK)
    @Operation(summary = "Сделать POST запрос")
    public String postMapping() {
        return "post";
    }

    @DeleteMapping
    @ResponseStatus(HttpStatus.OK)
    @Operation(summary = "Сделать DELETE запрос")
    public String deleteMapping() {
        return "delete";
    }

    @PutMapping
    @ResponseStatus(HttpStatus.OK)
    @Operation(summary = "Сделать PUT запрос")
    public String putMapping() {
        return "put";
    }
}
Конфигурация :
@Configuration
public class OpenApiConfig {
    @Bean
    public OpenAPI usersMicroserviceOpenAPI() {
        return new OpenAPI()
                .info(new Info().title("Сервис менеджер")
                        .description("Менеджер компонентов фильтрации, дедубликации, обогащения")
                        .version("1.0"));
    }
}
Swagger доступен по адресу http://localhost:8080/swagger-ui/index.html (UI часть)
А также по адресу http://localhost:8080/v3/api-docs доступна информация в виде JSON
// 20240611134421
// http://localhost:8080/v3/api-docs

{
  "openapi": "3.0.1",
  "info": {
    "title": "Сервис менеджер",
    "description": "Менеджер компонентов фильтрации, дедубликации, обогащения",
    "version": "1.0"
  },
  "servers": [
    {
      "url": "http://localhost:8080",
      "description": "Generated server url"
    }
  ],
  "paths": {
    "/": {
      "get": {
        "tags": [
          "test-controller"
        ],
        "summary": "Сделать GET запрос",
        "operationId": "getMapping_1",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "test-controller"
        ],
        "summary": "Сделать PUT запрос",
        "operationId": "putMapping_1",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "test-controller"
        ],
        "summary": "Сделать POST запрос",
        "operationId": "postMapping_1",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "test-controller"
        ],
        "summary": "Сделать DELETE запрос",
        "operationId": "deleteMapping_1",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {

  }
}
Основные библиотеки и плагины в gradle для работы с БД, валидацией, MVC, UI.
Spring validation
implementation 'org.springframework.boot:spring-boot-starter-validation:3.0.5'
Spring jpa
implementation 'org.springframework.boot:spring-boot-starter-data-jpa:3.0.5'
Databases
implementation 'org.postgresql:postgresql:42.5.4'
implementation 'com.zaxxer:HikariCP:5.0.1'
implementation 'org.jooq:jooq:3.17.8'
implementation 'redis.clients:jedis:4.3.1'
implementation 'org.mongodb:mongodb-driver-sync:4.9.1’
Spring boot thymeleaf template
implementation 'org.springframework.boot:spring-boot-starter-thymeleaf:3.0.5'
Plugins
id 'org.springframework.boot' version '3.0.6’ id 'java’




